# CLAUDE.md

## Project: Angular + NestJS User Management Playground (Better Auth)

### Goal
Create a monorepo that demonstrates user management with:

- Angular (latest) frontend using PrimeNG and NgRx (Store + Effects)
- NestJS backend using PostgreSQL + Prisma
- Better Auth (email + password only) integrated into NestJS (no plugins)
- Session strategy: Better Auth default (session-based)
- Two user roles: `ADMIN` and `USER`
- Extended user profile fields: `name`, `preferredName`, `role` plus Better Auth standard fields
- User listing via GraphQL Yoga (paginated, offset-based)
- Admin updates via Better Auth API (not GraphQL mutations)
- Email verification enabled, and changing a user's email triggers re-verification to the new address
- Emails sent via Resend using React Email templates

### Non-goals
- Password reset flow (unless required by Better Auth defaults)
- Social login providers
- Advanced UI polish beyond PrimeNG baseline
- Multi-tenancy and organizations

---

## Repo layout
Monorepo with bun workspaces under `/packages`:

- `/packages/ui` Angular app
- `/packages/api` NestJS app

At repo root:
- shared configs: Biome, Vitest defaults
- scripts to run dev, test, lint, typecheck

---

## Tooling requirements

### Package manager
- bun

### Formatting and linting
- Biome.js
- Semicolons enabled
- Line width 80
- Single quotes

### Testing
- Vitest for both UI and API
- Prefer integration tests
- Only add unit tests where integration tests are impractical

---

## Backend requirements (NestJS)

### Core stack
- NestJS
- PostgreSQL
- Prisma ORM
- GraphQL Yoga integrated into NestJS

### IDs and schema conventions
- Use UUID primary keys generated by Postgres (database-generated UUIDs)
- Prisma should reflect UUID columns and default generation in the database

### Auth
- Better Auth integrated into NestJS without plugins
- Email + password only
- Sessions: Better Auth default session-based strategy

### User model
Extend the Better Auth user record to include:

- `role`: enum `ADMIN` or `USER`
- `preferredName`: string (nullable or empty string is fine)

The user model must include:
- `email`
- `name`
- `preferredName`
- `role`
- plus standard Better Auth fields (id, emailVerified, createdAt, updatedAt, etc.)

### Authorization rules
- All authenticated users can view the user list
- Only admins can:
  - Edit user name, preferredName, email, role
  - Trigger email re-verification upon email change

### Email verification
- Email verification must be enabled
- When an admin changes a user's email:
  - Ensure a new verification flow is triggered to the new address
  - Ensure email verification status reflects the new unverified email until verified

### Emails
- Provider: Resend
- Templates: React Email
- No local mail viewer or console fallback is required

### GraphQL
- Use GraphQL Yoga inside NestJS
- Provide an offset-based paginated query for listing users
- Enforce auth: only authenticated users can query
- Fields returned should include at least:
  - id
  - email
  - name
  - preferredName
  - role
  - emailVerified
  - createdAt

### Update boundary (important)
- Listing users: GraphQL query
- Admin updates: Use Better Auth API (not GraphQL mutations)
  - Implement server-side endpoints in NestJS that call Better Auth's update mechanisms
  - The UI calls these endpoints for admin edits
- Document clearly which endpoints exist and how they are authorized

---

## Frontend requirements (Angular)

### Core stack
- Latest Angular
- PrimeNG for UI components
- NgRx Store + Effects for state management
- Angular router

### Architecture recommendation
Default to standalone components unless there is a specific reason to use NgModules.
If using standalone:
- Use `provideRouter`, `provideStore`, `provideEffects`
- Keep feature boundaries via folder structure and lazy routes

### UX flow
1. Unauthenticated users see a login screen
2. After login:
   - Regular users see a read-only list of users
   - Admin users see an editable list of users
3. Admin can click a user to open a PrimeNG modal dialog:
   - Edit name
   - Edit preferredName
   - Edit email (triggers email verification)
   - Edit role (ADMIN or USER)

### Data interactions
- Auth actions call Better Auth endpoints exposed by the backend
- Listing users uses GraphQL (query)
- Updating users uses NestJS endpoints that internally call Better Auth update flows

### Seeding expectations for demo
- Seed at least:
  - 1 admin user with known credentials
  - 1 regular user with known credentials
- UI should work against seeded users without manual DB setup beyond migrations and seed command

---

## Environment variables
Define .env requirements for both packages.

Minimum:
- `DATABASE_URL`
- Better Auth required environment variables (document them explicitly once chosen)
- `RESEND_API_KEY`
- `APP_BASE_URL` (for verification links)

---

## Developer commands (must be implemented)
At repo root:
- `bun install`
- `bun dev` runs both ui and api (simple concurrent runner)
- `bun test` runs all tests
- `bun lint` runs Biome
- `bun typecheck` runs type checks for api and ui

In api:
- `bun db:migrate` (Prisma migrate)
- `bun db:seed`

---

## Deliverables
Claude should produce:

- A working monorepo scaffold
- Running UI and API in dev mode
- Prisma schema and migrations using Postgres-generated UUIDs
- Seed script creating users with roles and preferredName
- GraphQL query for offset-based paginated user list
- Admin update capability (name, preferredName, email, role) implemented via Better Auth API
- Email verification sending via Resend + React Email
- Vitest integration tests for:
  - user listing pagination
  - admin-only update enforcement
  - email change triggers re-verification behavior

---

# Step-by-step implementation plan (execute sequentially)

## Step 0: Lock decisions in docs and code
- Sessions: Better Auth default session-based
- Pagination: offset-based
- Admin updates: NestJS endpoints calling Better Auth update APIs
- Emails: real Resend + React Email (no local fallback)
- Dev orchestration: simple bun scripts (no Turborepo/Nx)

Output: a short "Decisions" section in README.

---

## Step 1: Create monorepo scaffold
1. Initialize repo
2. Configure bun workspaces
3. Create `packages/ui` and `packages/api`
4. Add root scripts: dev, test, lint, typecheck
5. Add Biome config:
   - semicolons enabled
   - line width 80
   - single quotes
6. Add Vitest baseline config as needed

Acceptance:
- `bun install` works
- `bun lint` works

---

## Step 2: Backend scaffold (NestJS) + Prisma + Postgres
1. Create NestJS app in `packages/api`
2. Add Prisma
3. Add docker compose for Postgres
4. Configure Prisma schema:
   - UUID primary keys generated by Postgres defaults
5. Add migrations
6. Add seed script creating:
   - Admin user
   - Regular user

Acceptance:
- `bun -C packages/api db:migrate` works
- `bun -C packages/api db:seed` works
- Health endpoint returns OK

---

## Step 3: Integrate Better Auth in NestJS
1. Install Better Auth dependencies
2. Configure email/password auth
3. Enable email verification
4. Ensure user schema includes role + preferredName
5. Expose endpoints:
   - sign up
   - sign in
   - sign out
   - session/me

Acceptance:
- Can sign in with seeded admin
- `me` returns role + preferredName

---

## Step 4: Resend + React Email integration
1. Add React Email templates:
   - verification email
2. Integrate Resend in backend
3. Wire Better Auth email verification to use Resend templates

Acceptance:
- Verification email is sent through Resend

---

## Step 5: GraphQL Yoga users query (offset pagination)
1. Integrate GraphQL Yoga in NestJS
2. Implement `users(offset, limit)` query (or equivalent)
3. Enforce auth
4. Return required fields

Acceptance:
- Query works from client
- Pagination tested via Vitest integration tests

---

## Step 6: Admin update endpoints (call Better Auth API)
1. Implement admin guard in NestJS
2. Create endpoints for admin user updates:
   - update name
   - update preferredName
   - update role
   - update email
3. Email change behavior:
   - triggers new email verification to new email

Acceptance:
- Non-admin forbidden
- Admin can update
- Email change triggers verification

---

## Step 7: UI scaffold (Angular + PrimeNG + NgRx)
1. Create Angular app in `packages/ui`
2. Add PrimeNG
3. Add NgRx Store + Effects
4. Add routes:
   - `/login`
   - `/users`

Acceptance:
- UI runs
- Login screen shown when unauthenticated

---

## Step 8: Auth wiring and user list UI
1. Implement login form calling backend auth
2. Persist session per Better Auth session strategy
3. Implement users page:
   - GraphQL query for list (offset/limit)
   - Show table and pagination controls

Acceptance:
- Regular user sees read-only list
- Admin sees clickable rows

---

## Step 9: Admin modal edit flow
1. On admin click user row, open PrimeNG modal
2. Form fields:
   - name
   - preferredName
   - email
   - role
3. Save calls backend admin update endpoints
4. If email changed, show "verification sent" hint

Acceptance:
- Admin edits reflected in list
- Email change triggers verification

---

## Step 10: Testing (Vitest integration focus)
API tests:
- sign in
- users list pagination
- admin update allowed, regular user denied
- email change triggers verification flow

UI tests:
- minimal component tests for login and users list behavior

Acceptance:
- `bun test` passes

---

## Step 11: DX polish
1. Root `bun dev` runs api + ui concurrently
2. Document env vars and local setup in README
3. Ensure Biome + typecheck run cleanly

Acceptance:
- Fresh clone -> minimal steps -> working app

---

# Open questions (please answer)
1. What Node.js version should be targeted (20, 22, or other)?
2. Should `preferredName` be nullable or required (empty string allowed)?
3. Do you want the seed credentials hard-coded and documented (recommended), and if yes: any preference for the admin email?
4. Should admins be able to create new users from the UI, or only edit existing seeded users?
5. Should regular users be able to edit their own `name` and `preferredName`, or is all editing admin-only?
Angular architecture recommendation: standalone vs NgModules
I recommend standalone components for this project.

Why:

Angular has been steadily moving toward standalone as the default mental model. It reduces boilerplate and makes feature slices easier to structure.

For a monorepo playground, standalone makes it faster to scaffold routes, providers, and NgRx integration with less ceremony.

Lazy loading with standalone routes is clean and keeps the "feature folder" approach straightforward.

When I would choose NgModules instead:

If you have an older team codebase standard you want to mimic

If you want to practice module boundary patterns specifically

If you plan to generate lots of libraries where NgModule-based packaging conventions matter

For your goal (kickstart quickly, minimal ceremony, modern Angular), standalone is the better default.

I need a bit more from you
You cut off the last sentence: "keep it with" - I assumed "keep it with simple bun scripts". Confirm?

Also, please answer the 5 open questions at the bottom of the CLAUDE.md (Node version, preferredName nullable, seed creds, create-user in UI, and whether regular users can edit themselves).






You said:
I don't want ViTest defaults at the repository root, I want the ViTest setup in each package directory.

Target node version 24 as this is the latest LTS. Preferred name should be nullable. The seeding should be hardcoded in a seed.ts using Prisma Fabrica code.I don't know a whole lot about Angular, so if Angular has been steadily moving towards standalone as the default mental model, use that.Keep it with simple bun scripts, no NX or TurboRepo needed yet.


ChatGPT said:
markdown
Copy code
# CLAUDE.md

## Project: Angular + NestJS User Management Playground (Better Auth)

### Goal
Create a monorepo that demonstrates user management with:

- Angular (latest) frontend using PrimeNG and NgRx (Store + Effects)
- NestJS backend using PostgreSQL + Prisma
- Better Auth (email + password only) integrated into NestJS (no plugins)
- Session strategy: Better Auth default (session-based)
- Two user roles: `ADMIN` and `USER`
- Extended user profile fields: `name`, `preferredName`, `role` plus Better Auth standard fields
- User listing via GraphQL Yoga (paginated, offset-based)
- Admin updates via Better Auth API (not GraphQL mutations)
- Email verification enabled, and changing a user's email triggers re-verification to the new address
- Emails sent via Resend using React Email templates

### Decisions (locked)
- Node.js target: 24 (latest LTS)
- UI architecture: Angular standalone components (preferred modern default)
- Pagination: offset-based
- Admin updates: NestJS endpoints calling Better Auth update APIs
- Emails: real Resend + React Email (no local fallback)
- Dev orchestration: simple bun scripts (no Nx, no Turborepo)
- Vitest config: per-package only (no root Vitest defaults)
- Prisma IDs: UUIDs generated by Postgres defaults
- `preferredName`: nullable
- Seeding: hard-coded `seed.ts` using Prisma Fabrica

### Non-goals
- Password reset flow (unless required by Better Auth defaults)
- Social login providers
- Advanced UI polish beyond PrimeNG baseline
- Multi-tenancy and organizations

---

## Repo layout
Monorepo with bun workspaces under `/packages`:

- `/packages/ui` Angular app
- `/packages/api` NestJS app

At repo root:
- shared configs: Biome only (no Vitest defaults at root)
- scripts to run dev, test, lint, typecheck

---

## Tooling requirements

### Package manager
- bun

### Node.js
- Target Node 24

### Formatting and linting
- Biome.js
- Semicolons enabled
- Line width 80
- Single quotes

### Testing
- Vitest for both UI and API
- Vitest config lives inside each package:
  - `packages/api/vitest.config.ts`
  - `packages/ui/vitest.config.ts`
- Prefer integration tests
- Only add unit tests where integration tests are impractical

---

## Backend requirements (NestJS)

### Core stack
- NestJS
- PostgreSQL
- Prisma ORM
- GraphQL Yoga integrated into NestJS

### IDs and schema conventions
- Use UUID primary keys generated by Postgres (database-generated UUIDs)
- Ensure DB has UUID generation available (typically `pgcrypto` or `uuid-ossp`)
- Prisma should reflect UUID columns and default generation in the database

### Auth
- Better Auth integrated into NestJS without plugins
- Email + password only
- Sessions: Better Auth default session-based strategy

### User model
Extend the Better Auth user record to include:

- `role`: enum `ADMIN` or `USER`
- `preferredName`: string nullable

The user model must include:
- `email`
- `name`
- `preferredName`
- `role`
- plus standard Better Auth fields (id, emailVerified, createdAt, updatedAt, etc.)

### Authorization rules
- All authenticated users can view the user list
- Only admins can:
  - Edit user name, preferredName, email, role
  - Trigger email re-verification upon email change

### Email verification
- Email verification must be enabled
- When an admin changes a user's email:
  - Ensure a new verification flow is triggered to the new address
  - Ensure email verification status reflects the new unverified email until verified

### Emails
- Provider: Resend
- Templates: React Email
- No local mail viewer or console fallback is required

### GraphQL
- Use GraphQL Yoga inside NestJS
- Provide an offset-based paginated query for listing users
- Enforce auth: only authenticated users can query
- Fields returned should include at least:
  - id
  - email
  - name
  - preferredName
  - role
  - emailVerified
  - createdAt

### Update boundary (important)
- Listing users: GraphQL query
- Admin updates: Use Better Auth API (not GraphQL mutations)
  - Implement server-side endpoints in NestJS that call Better Auth's update mechanisms
  - The UI calls these endpoints for admin edits
- Document clearly which endpoints exist and how they are authorized

### Seeding
- Seed is implemented as a hard-coded `seed.ts` using Prisma Fabrica
- Seed at least:
  - 1 admin user with known credentials
  - 1 regular user with known credentials
- The seed must populate:
  - `email`, `name`, `preferredName` (nullable), `role`
  - and any required Better Auth fields so seeded users can log in

---

## Frontend requirements (Angular)

### Core stack
- Latest Angular
- PrimeNG for UI components
- NgRx Store + Effects for state management
- Angular router
- Standalone components

### Standalone architecture conventions
- Use `provideRouter`, `provideStore`, `provideEffects`
- Prefer lazy-loaded route-based feature slices under `src/app/features/*`
- Keep state in NgRx for:
  - session/me state
  - user list + pagination state
  - admin edit modal state

### UX flow
1. Unauthenticated users see a login screen
2. After login:
   - Regular users see a read-only list of users
   - Admin users see an editable list of users
3. Admin can click a user to open a PrimeNG modal dialog:
   - Edit name
   - Edit preferredName
   - Edit email (triggers email verification)
   - Edit role (ADMIN or USER)

### Data interactions
- Auth actions call Better Auth endpoints exposed by the backend
- Listing users uses GraphQL (query)
- Updating users uses NestJS endpoints that internally call Better Auth update flows

---

## Environment variables
Define env requirements for both packages.

Minimum:
- `DATABASE_URL`
- Better Auth required environment variables (document explicitly once selected)
- `RESEND_API_KEY`
- `APP_BASE_URL` (for verification links)

---

## Developer commands (must be implemented)

At repo root:
- `bun install`
- `bun dev` runs both ui and api (simple concurrent runner)
- `bun test` runs all tests in both packages
- `bun lint` runs Biome
- `bun typecheck` runs type checks for api and ui

In api:
- `bun db:migrate` (Prisma migrate)
- `bun db:seed` (runs `seed.ts`)

---

## Deliverables
Claude should produce:

- A working monorepo scaffold
- Running UI and API in dev mode
- Prisma schema and migrations using Postgres-generated UUIDs
- `seed.ts` using Prisma Fabrica creating users with roles and nullable preferredName
- GraphQL query for offset-based paginated user list
- Admin update capability (name, preferredName, email, role) implemented via Better Auth API
- Email verification sending via Resend + React Email
- Vitest integration tests (in each package) for:
  - user listing pagination
  - admin-only update enforcement
  - email change triggers re-verification behavior